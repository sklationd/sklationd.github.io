---
title: Tech For Impact
description: 사회혁신가를 위한 마음돌봄 서비스 개발
organization: Kakao x KAIST
from: "2023-08"
to: "2023-12"
---

![Tech For Impact](/techForImpact/logo.png)

## 데모 링크

-   [PWA](https://tech4-impact.vercel.app/onboarding)

## 기술 스택

-   Next.js
-   React.js
-   PWA
-   Tailwind CSS
-   Typescript
-   Firebase(FCM)
-   MongoDB

## [테크포임팩트](https://www.kakaoimpact.org/techforimpact) 란?

![Tech For Impact](/techForImpact/whatistechforimpact.png)

테크포임팩트는 카이스트와 카카오임팩트가 함께 올해 처음으로 개설한 **기술로 임팩트(사회혁신)을 가속화**하자는 카카오임팩트의 비전을 수업의 일환으로 경험 할 수 있는 프로그램이다.
사전에 정해진 9개 주제가 있고, 학생들을 대상으로 각자 희망하는 주제에 대한 신청을 받아서 선발과정을 거친 뒤 배정된 팀에서 펠로우님들, 카카오의 멘토님들과 함께 한 학기동안 프로젝트를 진행한다.
나는 원래도 관심이 있어서 개인적으로 프로젝트를 진행해본(분야 전문성이 부족해서 끝까지 완성하지는 못했지만) **다이어리 서비스 기획/개발**에 관한 주제로 신청을 했다.
꼭 하고 싶은 주제기도 해서 신청 폼을 조금 열심히 적었는데, 유사 프로젝트를 진행해 본 경험을 좋게 봐주셨는지 선발 될 수 있었다.

우리 팀은 총 6명이었고, 최종 제품에 대해서 대략적인 방향성만 잡혀 있던 상황이었기 때문에 디자인의 비중이 꽤 높아 디자인팀 3명, 개발팀 3명으로 나뉘어서 프로젝트를 진행하기로 했다.
나는 **개발팀장**을 맡았다. 현재(11월 중순)로서는 디자인이 어느정도 갈무리되어, 디자인팀 포함 6명이 모두 개발을 하고 있는 상황이다.
학교 수업치고는 꽤 규모가 있는 프로젝트/협업을 했기에, 이 과정에서 배운 것들을 기록해 두면 좋을 것 같아 생각나는 대로 적어보려 한다.

## 프로젝트 개괄

### 핵심 기능

![Tech For Impact](/techForImpact/feature.png)

-   감정 및 활동 기록
-   심리 검사
-   감정기록, 심리검사 통계
-   응급키트
    -   감정적으로 격앙되는 순간 나에게 도움을 줄 수 있는 생각들을 미리 정리해둘 수 있는 기능. ex) 내가 좋아하는 순간들, 언제라도 전화를 걸 수 있는 사람들
-   커뮤니티
    -   상담소측에서 게시물을 올리면, 사용자들이 댓글 등으로 소통 할 수 있는 구조
-   Push Notification
    -   상담소측에서 게시물을 올렸을 때
    -   하루에 두 번 정기적으로 감정기록을 할 수 있도록 유도하는 목적의 알림
-   어드민
    -   유저 메타 정보 목록 관리(활동 의제, 활동 단체)
    -   게시물, 댓글 관리
    -   심리검사 목록 관리
    -   응급키트 목록 관리

### 스택

-   디자인: Figma
-   프론트엔드: Next.js, React.js, Typescript, Tailwind CSS
-   백엔드: Next.js function(API Routes), MongoDB, Firebase(FCM)

## 프로젝트를 진행하며

### PWA를 선택한 이유

-   한 학기라는 짧은 시간동안 디자인부터 개발까지 모두 진행해야 하기 때문에 **빠른 개발 사이클**이 무엇보다도 중요했다.
-   네이티브 애플리케이션은 아무래도 Platform-specific 개발이 필요하기도 하고 구동 환경 자체가 무겁다보니 빠르게 개발 사이클을 돌리기에는 적합하지 않다고 판단했다.
-   PWA가 기능적인 부분, 퍼포먼스 등에서 네이티브 앱과 비교되는 부분이 있는건 사실이지만, 최근 IOS 16 업데이트부터 PWA에 푸시알림을 지원하기 시작하면서 우리가 구현하고자 하는 **핵심적인 기능**을 구현하는데에는 충분할 것이라 판단했다.
-   팀원들이 앱 개발 경험이 없는 사람이 많아서 러닝커브를 고려해봤을 때도 **웹 기반 서비스**를 개발하는 편이 더 효율적이라고 판단했다.
-   내가 개인적으로 PWA라는 기술에 관심이 많아 빠르게 프로젝트를 구축 할 수 있다는 사실도 어느정도 영향을 줬다.

### Next.js를 선택한 이유

-   뜻밖의 상담소(펠로우님들)측에서 최종 제품을 받았을 때 유지보수 할 인력이 없기 때문에 최대한 배포/관리에 **비용이 적게 드는 방식**을 선택해야 했고,
    Vercel에서 제공하는 호스팅과 Next.js 자체의 Function 기능을 이용하면, **별도의 서버 없이도** 서비스를 운영할 수 있겠다고 판단했다.
-   생산성 측면에서도, Next.js 프로젝트를 몇번 진행했을 때 프레임워크의 사용법이 직관적이어서 빠르게 프로토타이핑을 할 수 있다는 느낌을 받았었기 때문에 우리 프로젝트의 성격에 적합하다고 생각했다.

### Pages Routing vs App Routing

-   App Routing을 사용하면 서버 컴포넌트를 사용할 수 있다는 장점이 있지만,
    당장 우리 서비스가 어떻게 생겼는지, 어떤 기능을 포함할지 확실하게 모르는 상황에서 컴포넌트 별로 클라이언트 컴포넌트인지 서버 컴포넌트 인지 구분하며
    개발하는게 쉽지 않을거라고 판단을 했다. 그래서 일단은 익숙한 **Pages Routing**으로 진행했다.
-   지난 주 카카오아지트에 가서 멘토링을 하며 관련 질문을 드렸는데, 멘토님께서 아직 App Routing이 Production 레벨이 아닌 것 같다고 말씀해주셔서 어쩌다보니 옳은 결정을 한 셈이 됐다.
-   서버 컴포넌트를 사용하지 않아서 생기는 Client-Server Waterfall을 어떻게 해결했는지에 대해서는 아래 전역 상태 관리 글에서 적어보겠다.

### 전역 상태 관리

처음에 개발을 시작 할 때는, 아래 코드처럼 최상위 컴포넌트에서 데이터를 비동기적으로 받아오고 하위 컴포넌트들에게 props로 전달해주는 방식으로 개발을 했다.
다만 이런 식으로 개발을 하다보니 부모/자식 컴포넌트간의 종속성이 너무 강해져서 유지보수가 어려워지는 문제가 있었다. 찾아보니 Props Drilling이라는 잘 알려진 문제였다.

```js
export default function Component() {
    const [data, setData] = useState();

    useEffect(() => {
        // fetch data
        ...
    }, []);

    return (
        <div>
            <ComponentA data={data.componentAData}/>
            <ComponentB data={data.componentBData} />
        </div>
    );
}
```

그래서 각 컴포넌트에서 필요한 데이터를 직접 fetch하는 방식으로 리팩토링을 했는데, 비동기 요청의 개수가 늘어나기도 하고,
상위 컴포넌트의 비동기 데이터 요청 완료 여부에 따라서 하위 컴포넌트의 렌더링 여부가 결정된다면, 비동기 요청이 순차적으로 일어나면서 렌더링 또한 순차적으로 일어나면서
유저 경험을 저해하는 문제가 있었다. 이 역시도 Client-Server Waterfall이라고 잘 알려진 문제였고, 이 문제를 해결하기 위해서는 React 18에서 도입된 서버 컴포넌트를 사용해야 했다.

하지만, 서버컴포넌트를 사용하기에는 내가 해당 기술에 익숙하지 않았기 때문에, 두 선택지 중 하나를 선택하는 수 밖에 없었다.
결국 첫번째(모든 데이터를한번에 요청) 방법을 선택하는 대신, 커스텀 훅을 작성해서 컴포넌트간 종속성을 해소하는 방식으로 개발을 진행하기로 했다.
이와 같은 방식은 우리 팀의 협업구조에 적합하기도 했는데, MVC 패턴에서 Model, Controller는 커스텀 훅에서 전부 처리하고, View(컴포넌트)에서는 받아온 데이터를 어떻게 보여줄지만 신경쓰는 방식이
디자인 프로세스가 끝나고 개발에 합류한 디자인팀이 서버/DB 상호작용은 신경쓰지 않고 개발하는데에 도움이 되었기 때문이다.

최종적으로는 아래와 같은 구조가 되었다.

```js
// components/hook/data.tsx
export default useData() {
    const {data, error, isLoading, mutate} = useSWR();

    const getAData() {
        ...
        return data.componentAData;
    }

    const getBData() {
        ...
        return data.componentBData;
    }

    return {
        data,
        getAData(),
        getBData(),
    };
}

// components/ComponentA.tsx
export default function ComponentA() {
    const {getAData} = useData();
    const data = getAData();

    return (
        ...
    );
}

// components/ComponentB.tsx
export default function ComponentB() {
    const {getBData} = useData();
    const data = getBData();

    return (
        ...
    );
}

```

커스텀 훅을 작성하는 과정에서 SWR이라는 라이브러리를 사용했는데, 데이터 fetch 과정에서 유용한 Caching, Revalidation 등의 기능을 제공해준다.
멘토링에서 들은 바로는 React Query가 SWR와 유사한데 최근에 React Query가 더 관심을 받고 있다고 해서 이후에 또 Next.js 프로젝트를 진행하게 된다면 React Query를 사용해 볼 생각이다.

### 컴포넌트화 단위 - [참고 문서](https://fe-developers.kakaoent.com/2022/220505-how-page-part-use-atomic-design-system/)

컴포넌트화 단위를 정하는 것은 프로젝트의 규모가 커질수록 중요해진다고 머리로는 알고 있었는데, 프로젝트를 진행하면서 이를 확실히 체감할 수 있었다.
프로젝트 볼륨이 점점 커지면서, 페이지/컴포넌트 하나의 사이즈가 비대해지고 결국 이는 생산성의 저해로 이어졌다.
그래서 잠시 기능 개발을 멈추더라도 생산성을 위해 어느정도 컴포넌트화를 진행했다. 그 과정에서 명확한 기준이 필요하겠다 싶어서 멘토님께 받은 레퍼런스인 위 문서를 참고했다.
디자인과 개발이 병행되는 관계로 위 문서에서처럼 모든 구성요소를 Atomic하게 분해하기에는 쉽지 않았지만, 일단 컴포넌트 하나가 한 가지의 기능만을 담당하도록 하는 것을 목표로 컴포넌트를 나눴다.
결과적으로 코드의 가독성과 프로젝트를 파악하는데에 드는 비용이 줄어든 것 같기는 하나, 재사용 가능한 컴포넌트를 많이 만들었나라고 하면 그건 아닌 것 같다.
아무래도 그만큼의 재사용성을 얻어내기에는 프로젝트의 규모가 작아서 그런 것 같기도 하고, 내가 피그마를 보고 적절하게 컴포넌트를 나누는 경험이 부족해서 그런것도 있는 것 같다.
추후 좀 더 대규모의 체계화 된 프로젝트를 진행해 볼 기회가 있다면 이 부분이 어떤식으로 구현 되어있는지 확인해보고 싶다.

### MongoDB를 선택한 이유

-   개발과 디자인이 병렬로 진행되는 만큼 DB Schema가 개발 과정중에 **유동적으로** 바뀔거라 판단해서 NoSQL을 선택했다. (실제로도 그렇게 됐다.)
-   또, MongoDB Atlas를 사용하면 **무료**로 DB를 호스팅 할 수 있다는 점도 영향을 줬다.
-   다만 프로젝트의 규모가 커지다보면 이러한 유연함이 오히려 단점이 될 수도 있겠다는 생각이 들었다.

### 푸시 알림 구현 과정

우리 서비스의 경우 유저들의 심리적 에너지가 낮을 확률이 높기 때문에 유저가 다시 서비스로 돌아오는데 큰 역할을 할 수 있는 푸시 알림의 기능 구현이 필수적이었다.
Firebase의 fcm을 이용해 구현을 했고, 두 가지 유형의 푸시 알림을 보낼 수 있도록 개발했다.
첫째는 상담소 측에서 게시물을 올렸을 때 푸시알림을 보내는 비정기적 푸시 알림이고,
둘째는 하루에 두 번 감정기록을 할 수 있도록 유도하는 목적의 주기적인 푸시 알림이었다.
첫번째의 경우 Firebase의 Service Account API를 이용해서 포스팅의 완료와 함께 트리거하면 되었기 때문에 크게 문제가 되지 않았지만,
두번째 유형의 경우 특정 시간에 푸시 알림을 보내는 로직을 실행시키는 것이 필요했기 때문에,
Standalone 서버가 없는 우리 프로젝트의 구조에서 어떤 식으로 구현을 해야하나 고민을 많이 했다.
다행히도, Vercel 배포 시 하루 2개까지 Cron Job을 스케쥴링 할 수 있게 되어 있어서 고민한 시간에 비해 생각보다 간단하게 해결 할 수 있었다.

### 코드퀄리티

-   ESLint, Prettier를 사용해서 코드퀄리티를 관리했다. 어떤 특정 스타일이 정답이라기 보다는, **모든 팀원이 같은 스타일로 작성**을 하는게 중요하다고 생각을 해서
    Husky를 통해 Git commit 시점에 staging된 파일들에 대해서 자동으로 Linting과 코드 스타일링을 하도록 설정했다.
-   Linting 옵션은 next.js 프로젝트 생성시 기본으로 제공되는 `next/core-web-vitals`를 사용했다.

### 개발 팀장으로서 느낀 것들

-

## 기타

### 멘토님들의 멘토링 후기

-   카카오 공식 브런치에 [오프라인 멘토링 후기 글](https://brunch.co.kr/@andkakao/273)이 올라왔다. 중간쯤에 내가 세리 멘토님께 프로젝트 설명을 드리고 있는 사진이 있다.

### 후기

-   Ongoing..
