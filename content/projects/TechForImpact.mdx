---
title: Tech For Impact
description: 사회혁신가를 위한 마음돌봄 서비스 개발
organization: Kakao x KAIST
from: "2023-08"
to: "2023-12"
---

![Tech For Impact](/techForImpact/logo.png)

### 데모 링크

-   [PWA](https://tech4-impact.vercel.app/onboarding)

### 기술 스택

-   Next.js
-   React.js
-   PWA
-   Tailwind CSS
-   Typescript
-   Firebase(FCM)
-   MongoDB

### [테크포임팩트](https://www.kakaoimpact.org/techforimpact) 란?

![Tech For Impact](/techForImpact/whatistechforimpact.png)

테크포임팩트는 카이스트와 카카오임팩트가 함께 개설한 수업으로 웹페이지에서 확인할 수 있는 것처럼 기술로 임팩트(사회혁신)을 가속화한다는 것이 큰 골자인데,
사전에 정해진 주제가 있고, 학생들을 대상으로 희망하는 주제에 대한 신청을 받아서 선발과정을 거친 뒤 배정된 팀에서 펠로우님들과 함께 한 학기동안 프로젝트를 진행한다.
나같은 경우에는 원래도 관심이 있기도 했고, 개인적으로도 프로젝트를 진행해보기도 했던(끝까지 완성하지는 못했지만) 사회혁신가를 위한 다이어리 서비스 기획/개발에 관한 주제로 신청을 했고,
운이 좋게도 선발 될 수 있었다. 우리 팀은 6명으로 구성되어 있었고, 최종 제품에 대해서 대략적인 방향성만 잡혀 있던 상황이었기 때문에 디자인의 비중이 꽤 높을 것으로 생각되어 디자인팀 3명, 개발팀 3명으로 나뉘어서 프로젝트를 진행하기로 했다.
나는 개발팀장을 맡았다. 현재(11월 중순)로서는 디자인이 어느정도 갈무리되어, 디자인팀 포함 6명이 모두 개발을 하고 있는 상황인데, 학교 수업치고는 꽤 볼륨이 있는 프로젝트/협업을 했기에, 이 과정에서 배운 것들을 기록해 두면 좋을 것 같아 생각나는 대로 적어보려 한다.

### 프로젝트 개괄

#### 핵심 기능

![Tech For Impact](/techForImpact/feature.png)

-   감정기록
-   심리검사
-   감정기록, 심리검사 통계
-   응급키트
    -   감정적으로 격앙되는 순간 나에게 도움을 줄 수 있는 생각들을 미리 정리해둘 수 있는 기능. ex) 내가 좋아하는 순간들, 언제라도 전화를 걸 수 있는 사람들
-   커뮤니티
    -   상담소측에서 게시물을 올리면, 사용자들이 댓글 등으로 소통 할 수 있는 구조
-   어드민(별도)

#### 스택

-   디자인: Figma
-   프론트엔드: Next.js, React.js, Typescript, Tailwind CSS
-   백엔드: Next.js function(API Routes), MongoDB, Firebase(FCM)

#### PWA를 선택한 이유

-   한 학기라는 짧은 시간동안 디자인부터 개발까지 모두 진행해야 하기 때문에 빠른 개발 사이클이 무엇보다도 중요했다.
-   네이티브 애플리케이션은 아무래도 Platform-specific 개발이 필요하기도 하고 구동 환경 자체가 무겁다보니 빠르게 개발 사이클을 돌리기에는 적합하지 않다고 판단했다.
-   PWA가 기능적인 부분, 퍼포먼스 등에서 네이티브 앱과 비교되는 부분이 있는건 사실이지만, 최근 IOS 16 업데이트부터 PWA에 푸시알림을 지원하기 시작하면서 우리가 구현하고자 하는 핵심적인 기능을 구현하는데에는 충분할 것이라 판단했다.
-   팀원들이 앱 개발 경험이 없는 사람이 많아서 러닝커브를 고려해봤을 때도 웹 기반 서비스를 개발하는 편이 더 효율적이라고 판단했다.
-   내가 개인적으로 PWA라는 기술에 관심이 있어 빠르게 프로젝트를 구축 할 수 있다는 사실도 어느정도 영향을 줬다.

#### Next.js를 선택한 이유

-   뜻밖의 상담소(펠로우님들)측에서 최종 제품을 받았을 때 유지보수 할 인력이 없기 때문에 최대한 배포/관리에 비용이 적게 드는 방식을 선택해야 했고,
    Vercel에서 제공하는 호스팅과 Next.js 자체의 Function 기능을 이용하면, 별도의 서버 없이도 서비스를 운영할 수 있겠다고 판단했다.
-   생산성 측면에서도, Next.js 프로젝트를 몇번 진행했을 때 프레임워크의 사용법이 직관적이어서 빠르게 프로토타이핑을 할 수 있다는 느낌을 받았었기 때문에 우리 프로젝트의 성격에 적합하다고 생각했다.

#### MongoDB를 선택한 이유

-   개발과 디자인이 병렬로 진행되는 만큼 DB Schema가 개발 과정중에 유동적으로 바뀔거라 판단해서 NoSQL을 선택했다. (실제로도 그렇게 됐다.)
-   또, MongoDB Atlas를 사용하면 무료로 DB를 호스팅 할 수 있다는 점도 영향을 줬다.

### Pages Routing vs App Routing

-   App Routing을 사용하면 서버 컴포넌트를 사용할 수 있다는 장점이 있지만,
    당장 우리 서비스가 어떻게 생겼는지, 어떤 기능을 포함할지 확실하게 모르는 상황에서 컴포넌트 별로 클라이언트 컴포넌트인지 서버 컴포넌트 인지 구분하며
    개발하는게 쉽지 않을거라고 판단을 했다. 그래서 일단은 익숙한 Pages Routing으로 진행했다.
-   지난 주 카카오아지트에 가서 멘토링을 하며 관련 질문을 드렸는데, 멘토님께서 아직 App Routing이 Production 레벨이 아닌 것 같다고 말씀해주셔서 어쩌다보니 옳은 결정을 한 셈이 됐다.
-   서버 컴포넌트를 사용하지 않아서 생기는 Client-Server waterfall을 어떻게 해결했는지에 대해서는 아래 전역 상태 관리 글에서 적어보겠다.

### 전역 상태 관리

처음에 개발을 시작 할 때는, 아래 코드처럼 최상위 컴포넌트에서 데이터를 비동기적으로 받아오고 하위 컴포넌트들에게 props로 전달해주는 방식으로 개발을 했다.
다만 이런 식으로 개발을 하다보니 부모/자식 컴포넌트간의 종속성이 너무 강해져서 유지보수가 어려워지는 문제가 있었다. 찾아보니 Props Drilling이라고 하는 꽤나 유명한 문제였다.

```js
export default function Component() {
    const [data, setData] = useState();

    useEffect(() => {
        // fetch data
        ...
    }, []);

    return (
        <div>
            <ComponentA data={data.componentAData}/>
            <ComponentB data={data.componentBData} />
        </div>
    );
}
```

그래서 아래 코드와 같이 각 컴포넌트에서 필요한 데이터를 직접 fetch하는 방식으로 리팩토링을 했는데, 요청의 개수가 늘어나기도 하고,
그러다보니 `ComponentA`의 요청이 처리되는 동안은 `ComponentB`가 렌더링 되지 않는 문제가 발생했다.
찾아보니 Client-Server Waterfall이라고 하는 문제였고, 이 문제를 해결하기 위해서는 서버 컴포넌트를 사용해야 했다.

```js
export default function Component() {
    return (
        <div>
            <ComponentA />
            <ComponentB />
        </div>
    );
}
```

하지만, 서버컴포넌트를 사용하기에는 내가 해당 기술에 익숙하지 않았기 때문에, 두 선택지 중 하나를 선택하는 수 밖에 없었다.
결국 위 두 선택지 중 첫번째를 선택하되, 커스텀 훅을 작성해서 컴포넌트간 종속성을 해소하는 방식으로 개발을 진행하기로 했다.
이와 같은 방식은 우리 팀의 협업구조에 적합하기도 했는데, Model, Controller는 커스텀 훅에서 전부 처리하고, View(컴포넌트)에서는 받아온 데이터를 어떻게 보여줄지만 신경쓰는 방식은
디자인 프로세스가 끝나고 개발에 합류한 디자인팀이 서버/DB 상호작용은 신경쓰지 않고 개발하는데에 도움이 되었다.

최종적으로는 아래와 같은 구조가 되었다.

```js
// components/hook/data.tsx
export default useData() {
    const {data, error, isLoading, mutate} = useSWR();

    const getAData() {
        return data.componentAData;
    }

    const getBData() {
        return data.componentBData;
    }

    return {
        data,
        getAData(),
        getBData(),
    };
}

// components/ComponentA.tsx
export default function ComponentA() {
    const {getAData} = useData();
    const data = getAData();

    return (
        ...
    );
}

// components/ComponentB.tsx
export default function ComponentB() {
    const {getBData} = useData();
    const data = getBData();

    return (
        ...
    );
}

```

이 과정에서 SWR이라는 라이브러리를 사용했는데, 데이터 fetch 과정에서 유용한 Caching, Revalidation 등의 기능을 제공해준다.
멘토링에서 들은 바로는 React Query랑 유사한데 최근에 React Query가 더 관심을 받고 있다고 해서 이후에 또 Next.js 프로젝트를 진행하게 된다면 React Query를 사용해 볼 생각이다.

### 컴포넌트화 단위 - [참고 문서](https://fe-developers.kakaoent.com/2022/220505-how-page-part-use-atomic-design-system/)

컴포넌트화 단위를 정하는 것은 프로젝트의 규모가 커질수록 중요해진다고 머리로는 알고 있었는데, 프로젝트를 진행하면서 이를 확실히 체감할 수 있었다.
프로젝트 볼륨이 점점 커지면서, 페이지/컴포넌트 하나의 사이즈가 비대해지고 결국 이는 생산성의 저해로 이어졌다.
그래서 잠시 기능 개발을 멈추더라도 생산성을 위해 어느정도 컴포넌트화를 진행했다. 그 과정에서 명확한 기준이 필요하겠다 싶어서 멘토님께 받은 레퍼런스인 위 문서를 참고했다.
디자인과 개발이 병행되는 관계로 위 문서에서처럼 모든 구성요소를 Atomic하게 분해하기에는 쉽지 않았지만, 일단 컴포넌트 하나가 한 가지의 기능만을 담당하도록 하는 것을 목표로 컴포넌트를 나눴다.
결과적으로 코드의 가독성과 프로젝트를 파악하는데에 드는 비용이 줄어든 것 같기는 하나, 재사용 가능한 컴포넌트를 많이 만들었나라고 하면 그건 아닌 것 같다.
아무래도 그만큼의 재사용성을 얻어내기에는 프로젝트의 규모가 작아서 그런 것 같기도 하고, 내가 피그마를 보고 적절하게 컴포넌트를 나누는 경험이 부족해서 그런것도 있는 것 같다.
추후 좀 더 대규모의 체계화 된 프로젝트를 진행해 볼 기회가 있다면 이 부분이 어떤식으로 구현 되어있는지 확인해보고 싶다.

### 코드퀄리티

-   eslint, prettier, husky

### R&R

-
